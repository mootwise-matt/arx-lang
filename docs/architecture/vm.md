# ARX Virtual Machine Architecture

## Overview

The ARX Virtual Machine (VM) is a stack-based interpreter that executes bytecode generated by the ARX compiler. It provides a runtime environment for ARX programs with memory management, object system support, and cross-platform execution capabilities.

## ðŸŽ‰ **MAJOR MILESTONE: Object-Oriented Programming Complete**

The VM now features complete object-oriented programming support:
- **Method Calls**: `obj.method()` âœ… Working - Returns proper method results
- **Field Access**: `obj.field` âœ… Working - Returns field values
- **Object Creation**: `new ClassName` âœ… Working - Creates object instances
- **Dynamic Execution**: All OO operations execute at runtime with proper return values

## VM Architecture

### Core Components

#### 1. Instruction Interpreter
- **Purpose**: Execute bytecode instructions
- **Input**: ARX module bytecode
- **Output**: Program execution results

**Key Components**:
- `arx_vm_context_t`: VM execution state
- `instruction_t`: Bytecode instruction structure
- `vm_execute_instruction()`: Execute single instruction
- `vm_execute_operation()`: Execute operation instructions

#### 2. Memory Manager
- **Purpose**: Manage runtime memory allocation
- **Features**: Object allocation, garbage collection, memory safety

**Key Components**:
- `vm_allocate_object()`: Allocate new objects
- `vm_free_object()`: Deallocate objects
- `vm_gc_collect()`: Garbage collection
- `vm_memory_stats()`: Memory usage statistics

#### 3. Stack Manager
- **Purpose**: Manage execution stack
- **Features**: Stack operations, frame management, call stack

**Key Components**:
- `vm_push()`: Push value onto stack
- `vm_pop()`: Pop value from stack
- `vm_peek()`: Peek at stack top
- `vm_stack_depth()`: Get current stack depth

#### 4. Object System
- **Purpose**: Handle object-oriented features
- **Features**: Object creation, method calls, field access, inheritance

**Key Components**:
- `vm_create_object()`: Create new object instances
- `vm_call_method()`: Call object methods
- `vm_access_field()`: Access object fields
- `vm_inheritance_check()`: Check inheritance relationships

#### 5. ARX Module Loader
- **Purpose**: Load and parse ARX module files
- **Features**: Section loading, symbol resolution, string table management

**Key Components**:
- `vm_load_module()`: Load ARX module
- `vm_load_strings()`: Load string table
- `vm_load_symbols()`: Load symbol table
- `vm_resolve_symbol()`: Resolve symbol references

## VM Data Structures

### VM Context

```c
typedef struct {
    // Execution state
    instruction_t *instructions;     // Loaded instructions
    size_t instruction_count;       // Number of instructions
    size_t pc;                      // Program counter
    
    // Stack management
    vm_value_t *stack;              // Execution stack
    size_t stack_size;              // Stack size
    size_t stack_top;               // Stack top pointer
    
    // Memory management
    vm_object_t *objects;           // Object heap
    size_t object_count;            // Number of objects
    size_t object_capacity;         // Object heap capacity
    
    // String management
    vm_string_table_t string_table; // String table
    bool utf8_enabled;              // UTF-8 support flag
    
    // Symbol management
    vm_symbol_table_t symbol_table; // Symbol table
    
    // Debug and error handling
    bool debug_mode;                // Debug output flag
    int error_count;                // Error count
    char error_message[256];        // Last error message
} arx_vm_context_t;
```

### VM Value

```c
typedef struct {
    vm_value_type_t type;           // Value type
    union {
        int64_t integer;            // Integer value
        bool boolean;               // Boolean value
        char character;             // Character value
        double real;                // Real number value
        vm_object_t *object;        // Object reference
        vm_string_t *string;        // String reference
    } data;
} vm_value_t;
```

### VM Object

```c
typedef struct {
    vm_class_t *class_info;         // Class information
    vm_value_t *fields;             // Object fields
    size_t field_count;             // Number of fields
    size_t field_capacity;          // Field capacity
    bool is_allocated;              // Allocation status
} vm_object_t;
```

### VM String

```c
typedef struct {
    char *data;                     // String data
    size_t length;                  // String length
    size_t capacity;                // String capacity
    bool is_utf8;                   // UTF-8 encoding flag
} vm_string_t;
```

## Instruction Set

### Load Instructions

- **`VM_LIT`**: Load literal value onto stack
- **`VM_LOD`**: Load variable value onto stack
- **`VM_STO`**: Store stack value to variable

### Operation Instructions

- **`OPR_ADD`**: Addition operation
- **`OPR_SUB`**: Subtraction operation
- **`OPR_MUL`**: Multiplication operation
- **`OPR_DIV`**: Division operation
- **`OPR_POW`**: Exponentiation operation (^)
- **`OPR_MOD`**: Modulo operation (%)

### String Operations

- **`OPR_STR_CREATE`**: Create string object
- **`OPR_STR_CONCAT`**: String concatenation
- **`OPR_STR_LENGTH`**: Get string length
- **`OPR_STR_EQUAL`**: String equality check
- **`OPR_INT_TO_STR`**: Convert integer to string
- **`OPR_STR_TO_INT`**: Convert string to integer

### Object Operations

- **`OPR_OBJ_NEW`**: Create new object
- **`OPR_OBJ_CALL_METHOD`**: Call object method
- **`OPR_OBJ_GET_FIELD`**: Access object field
- **`OPR_OBJ_SET_FIELD`**: Set object field

### I/O Operations

- **`OPR_OUTSTRING`**: Output string to console
- **`OPR_WRITELN`**: Write line to console
- **`OPR_READINT`**: Read integer from console
- **`OPR_READSTRING`**: Read string from console

### Control Flow

- **`VM_JMP`**: Unconditional jump
- **`VM_JZ`**: Jump if zero
- **`VM_JNZ`**: Jump if not zero
- **`VM_CALL`**: Call procedure/function
- **`VM_RET`**: Return from procedure/function

### System Operations

- **`VM_HALT`**: Halt execution
- **`OPR_DEBUG`**: Debug output
- **`OPR_ERROR`**: Error handling

## Execution Model

### Stack-Based Execution

The VM uses a stack-based execution model where:
1. **Operands**: Values are pushed onto the stack
2. **Operations**: Operations pop operands and push results
3. **Results**: Final results remain on the stack

### Example Execution

```arx
result := (20 * 5) / 2;
```

**Generated Bytecode**:
```
VM_LIT 20        # Push 20
VM_LIT 5         # Push 5
OPR_MUL          # Pop 5, 20; Push 100
VM_LIT 2         # Push 2
OPR_DIV          # Pop 2, 100; Push 50
VM_STO result    # Pop 50; Store to result
```

### Memory Management

#### Object Allocation
- Objects are allocated on the heap
- Each object has a class reference and field storage
- Objects are garbage collected when no longer referenced

#### String Management
- Strings are stored in a string table
- String concatenation creates new string objects
- UTF-8 encoding support for international characters

#### Garbage Collection
- Reference counting for automatic memory management
- Cyclic reference detection and cleanup
- Memory compaction for efficiency

## Error Handling

### Error Types

- **Runtime Errors**: Division by zero, null pointer access
- **Type Errors**: Type mismatches, invalid operations
- **Memory Errors**: Out of memory, stack overflow
- **I/O Errors**: File access, console I/O failures

### Error Recovery

- **Graceful Degradation**: Continue execution when possible
- **Error Reporting**: Detailed error messages with line numbers
- **Debug Information**: Stack traces and variable states
- **Safe Shutdown**: Clean resource cleanup on errors

## Performance Characteristics

### Execution Speed

- **Target**: 1M+ instructions per second
- **Optimization**: Instruction caching and optimization
- **Memory Usage**: Efficient memory management
- **Scalability**: Linear performance with program size

### Memory Usage

- **Stack**: Configurable stack size (default 64KB)
- **Heap**: Dynamic object allocation
- **String Table**: Efficient string storage and sharing
- **Symbol Table**: Fast symbol lookup and resolution

## Debugging Support

### Debug Features

- **Step Execution**: Single-step through instructions
- **Breakpoints**: Set breakpoints on instructions
- **Variable Inspection**: View variable values
- **Stack Inspection**: Examine execution stack
- **Memory Inspection**: View object heap

### Debug Output

- **Instruction Tracing**: Log executed instructions
- **Stack Tracing**: Log stack operations
- **Memory Tracing**: Log memory allocations
- **Error Tracing**: Log error conditions

## Cross-Platform Support

### Supported Platforms

- **macOS**: Apple Silicon and Intel
- **Linux**: x86_64 and ARM64
- **Windows**: x86_64 (planned)

### Platform-Specific Features

- **Console I/O**: Platform-specific console handling
- **File I/O**: Platform-specific file operations
- **Memory Management**: Platform-specific memory allocation
- **Threading**: Platform-specific threading support (future)

## Future Enhancements

### Planned Features

- **JIT Compilation**: Just-in-time compilation for performance
- **Parallel Execution**: Multi-threaded execution support
- **Advanced Garbage Collection**: Generational GC, concurrent GC
- **Debugging Tools**: Integrated debugger and profiler
- **Performance Profiling**: Built-in performance analysis

### Extensibility

- **Plugin System**: Loadable VM extensions
- **Custom Instructions**: User-defined instruction sets
- **Native Code Integration**: Call native libraries
- **Network Support**: Distributed execution capabilities

## Implementation Notes

### Memory Safety

- **Bounds Checking**: Array and string bounds validation
- **Null Pointer Checks**: Prevent null pointer dereferences
- **Type Safety**: Runtime type checking and validation
- **Stack Overflow Protection**: Stack bounds checking

### Thread Safety

- **Single-Threaded**: Current implementation is single-threaded
- **Thread-Safe Design**: Architecture supports future multi-threading
- **Atomic Operations**: Thread-safe primitive operations
- **Lock-Free Data Structures**: Efficient concurrent data structures

### Error Recovery

- **Exception Handling**: Structured exception handling
- **Resource Cleanup**: Automatic resource management
- **State Restoration**: Restore consistent state after errors
- **Graceful Degradation**: Continue execution when possible
