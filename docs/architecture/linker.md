# ARX Linker Architecture

## Overview

The ARX linker is a compile-time tool responsible for resolving method and field references by replacing placeholder tokens with pre-calculated offsets. This enables efficient runtime object access without string-based lookups.

## Purpose

The linker bridges the gap between the high-level AST (which contains string-based method/field references) and the low-level bytecode (which needs numeric offsets for fast access). It performs the following key functions:

1. **Token Replacement**: Replaces string-based method/field references with calculated offsets
2. **Address Resolution**: Resolves method and field addresses relative to class base addresses
3. **Bytecode Patching**: Updates generated bytecode with resolved addresses
4. **Class Layout Calculation**: Determines memory layout for classes and their members

## Architecture

### Input
- **Class Manifest**: Collection of class definitions with method and field information
- **Method Manifest**: Array of method entries with pre-calculated offsets
- **Field Manifest**: Array of field entries with pre-calculated offsets
- **Generated Bytecode**: Instructions with placeholder tokens for method/field access

### Output
- **Patched Bytecode**: Instructions with resolved offsets instead of placeholder tokens
- **Resolved Addresses**: Method and field addresses ready for VM execution

## Process Flow

```
AST (with string tokens) 
    ↓
Code Generator (collects class info + generates bytecode)
    ↓
Linker (replaces tokens with offsets)
    ↓
VM (uses resolved offsets for fast access)
```

## Key Components

### Linker Context
```c
typedef struct {
    class_entry_t *classes;           // Class manifest
    size_t class_count;               // Number of classes
    method_entry_t *methods;          // Method manifest with offsets
    size_t method_count;              // Number of methods
    field_entry_t *fields;            // Field manifest with offsets
    size_t field_count;               // Number of fields
    uint64_t base_address;            // Base address for class layout
    uint64_t current_offset;          // Current offset in memory layout
} linker_context_t;
```

### Method Entry
```c
typedef struct {
    char        method_name[32];   // Method name (null-terminated)
    uint64_t    method_id;         // Unique method ID
    uint64_t    offset;            // Offset from class base address
    uint32_t    parameter_count;   // Number of parameters
    uint32_t    flags;             // Method flags (static, virtual, etc.)
} method_entry_t;
```

### Field Entry
```c
typedef struct {
    char        field_name[32];    // Field name (null-terminated)
    uint64_t    field_id;          // Unique field ID
    uint64_t    offset;            // Offset from object base address
    uint32_t    type_id;           // Type ID (for type checking)
    uint32_t    flags;             // Field flags (private, protected, etc.)
} field_entry_t;
```

## Token Replacement Process

### 1. Method Call Resolution
- **Input**: `AST_METHOD_CALL` nodes with string values like "object.method"
- **Process**: Parse class and method names, look up offsets in method manifest
- **Output**: Replace string value with calculated method offset

### 2. Field Access Resolution
- **Input**: `AST_FIELD_ACCESS` nodes with string values like "object.field"
- **Process**: Parse class and field names, look up offsets in field manifest
- **Output**: Replace string value with calculated field offset

### 3. Bytecode Patching
- **Input**: Generated bytecode with placeholder operands
- **Process**: Scan bytecode for method/field access instructions, replace operands with resolved offsets
- **Output**: Patched bytecode ready for VM execution

## Offset Calculation

### Method Offsets
- Methods are assigned sequential offsets within each class
- Each method gets a fixed size allocation (e.g., 0x100 bytes)
- Method offset = class_base_offset + (method_index * method_size)

### Field Offsets
- Fields are assigned sequential offsets within each object instance
- Each field gets its type-specific size allocation
- Field offset = object_base_address + (field_index * field_size)

## Runtime Usage

After linking, the VM can efficiently access methods and fields:

```c
// Method call: base_address + method_offset
uint64_t method_address = object_base_address + method_offset;

// Field access: base_address + field_offset
uint64_t field_address = object_base_address + field_offset;
```

## Benefits

1. **Performance**: No string lookups at runtime
2. **Efficiency**: Simple addition operations for address calculation
3. **Predictability**: All offsets calculated at compile time
4. **Memory Safety**: Bounds checking possible with known offsets
5. **Debugging**: Clear mapping between source code and memory layout

## Integration

The linker is integrated into the compilation process:

1. **Code Generation**: Collects class/method/field information with offsets
2. **Linking Phase**: Replaces placeholder tokens with calculated offsets
3. **Module Writing**: Writes resolved information to .arxmod file
4. **VM Loading**: VM loads pre-calculated offsets for fast access

## Future Enhancements

- **Inheritance Support**: Handle method overriding and field shadowing
- **Virtual Methods**: Support for dynamic dispatch
- **Optimization**: Dead code elimination and method inlining
- **Debug Information**: Source-to-bytecode mapping for debugging
