# ARX Debugging Guide

## Overview
This document provides comprehensive debugging techniques and tools for the ARX programming language compiler and virtual machine.

## Debugging Tools

### Compiler Debugging

#### Debug Flags
```bash
# Enable debug output
./arx -debug program.arx

# Show generated bytecode
./arx -debug -show-bytecode program.arx

# Show symbol table
./arx -debug -show-symbols program.arx

# Show all debug information
./arx -debug -show-bytecode -show-symbols program.arx
```

#### Debug Output Examples

##### Lexer Debug Output
```
Token: MODULE (module)
Token: IDENT (MyModule)
Token: SEMICOL
Token: CLASS (class)
Token: IDENT (App)
```

##### Parser Debug Output
```
Parsing module
Parsing class
Parsing method
Parsing statement - token: IDENT
Found identifier with :=, parsing assignment
Assignment with NEW expression detected
Parsing NEW expression
NEW class: MyClass
Stored NEW class name: MyClass
```

##### Code Generation Debug Output
```
Generating code for method: Main
Generating NEW expression for class: MyClass
Constructor parameters: 2 parameters, has_params: true
Emitted: opcode=0, level=0, operand=940
Emitted: opcode=1, level=0, operand=46
Generated NEW instruction for class 'MyClass' (ID: 940)
```

##### Symbol Table Debug Output
```
=== Symbol Table Dump ===
Total symbols: 3
Current scope level: 0

Scope: global (level 0, 3 symbols)
  Symbol: App (type: 5, scope: 0, line: 0)
  Symbol: ParentClass (type: 5, scope: 0, line: 0)
  Symbol: ChildClass (type: 5, scope: 0, line: 0) extends ParentClass
```

### VM Debugging

#### Debug Flags
```bash
# Enable VM debug output
./arxvm -debug program.arxmod

# Step through execution
./arxvm -debug -step program.arxmod

# Show memory state
./arxvm -debug -dump program.arxmod

# Trace execution
./arxvm -debug -trace program.arxmod
```

#### VM Debug Output Examples

##### Module Loading
```
=== ARX Virtual Machine ===
Version: 1.0
Architecture: ARM64
Debug mode: enabled

Loading program: program.arxmod
ARX module reader initialized for 'program.arxmod'
ARX module validation successful
  Version: 1
  TOC offset: 64
  TOC size: 200
  Data offset: 384
  Data size: 73
TOC loaded: 5 sections
  Section 0:  (offset: 0, size: 63)
  Section 1: STRINGS (offset: 63, size: 0)
  Section 2: SYMBOLS (offset: 63, size: 0)
  Section 3: DEBUG (offset: 63, size: 0)
  Section 4: APP (offset: 63, size: 10)
```

##### Instruction Execution
```
Starting VM execution
PC=0: opcode=0, level=0, operand=0
PC=1: opcode=0, level=0, operand=0
PC=2: opcode=1, level=0, operand=20
PC=3: opcode=10, level=0, operand=0
VM halted
```

##### Runtime State
```
=== ARX VM Runtime State ===
PC: 3
Stack top: 2/16384
Instructions executed: 4
Halted: yes
Call stack depth: 0
String count: 0
```

### ARX Module Inspection

#### Module Information
```bash
# Show module sections
./arxmod_info -sections program.arxmod

# Show hex dump
./arxmod_info -hex program.arxmod

# Show module information
./arxmod_info -info program.arxmod
```

#### Module Debug Output Examples

##### Section Information
```
=== ARX Module Sections ===
Section 0: 
  Offset: 0
  Size: 63 bytes
  Flags: 0x00000000

Section 1: STRINGS
  Offset: 63
  Size: 0 bytes
  Flags: 0x00000000

Section 2: SYMBOLS
  Offset: 63
  Size: 0 bytes
  Flags: 0x00000000
```

##### Hex Dump
```
=== ARX Module Header (Hex) ===
Offset  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  ASCII
-------------------------------------------------------- ------
00000000 41 52 58 4D 4F 44 00 00 01 00 00 00 00 00 00 00  ARXMOD..........
00000010 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  @.......@.......
00000020 C8 00 00 00 00 00 00 00 80 01 00 00 00 00 00 00  ................
```

## ðŸ›¡ï¸ **INFINITE LOOP PROTECTION AND DEBUGGING**

### VM Infinite Loop Protection

The ARX VM now includes comprehensive infinite loop protection mechanisms:

#### Execution Step Limits
```bash
# VM automatically stops after 5,000 steps
VM: Execution stopped after 5000 steps (infinite loop protection)
```

#### PC Stuck Detection
```bash
# VM detects when PC is stuck at same instruction
VM: PC stuck at 18 for 100 steps (infinite loop detected)
```

#### Call Stack Limits
```bash
# VM prevents excessive recursion
Error: Call stack depth limit exceeded (50 levels)
```

#### Stack Safety
```bash
# VM prevents stack overflow/underflow
Error: Stack overflow detected - halting VM
Error: Stack underflow detected - halting VM
```

### Label Resolution Debugging

#### Label Table Debug Output
```bash
# Compiler shows label resolution process
Resolving 18 labels...
Found jump instruction 18: opcode=7, label_id=1
Resolved jump at instruction 18: label 1 -> instruction 30
```

#### Multi-Context Label Merging
```bash
# Compiler shows label merging across contexts
Merging 18 labels from class App into main context
```

#### Linker Integration
```bash
# Linker skips already-resolved jump instructions
Linker: Skipping jump instruction 18 (already resolved by codegen)
```

### Debugging Infinite Loop Issues

#### 1. Check Label Resolution
```bash
# Enable debug mode to see label resolution
./arx -debug program.arx 2>&1 | grep -A5 -B5 "Resolving\|Found jump\|Resolved jump"
```

#### 2. Check VM Execution
```bash
# Enable VM debug mode to see execution flow
./arxvm -debug program.arxmod 2>&1 | grep -A5 -B5 "PC stuck\|Execution stopped\|infinite loop"
```

#### 3. Check Jump Instructions
```bash
# Show generated bytecode to verify jump targets
./arx -debug -show-bytecode program.arx
```

## Common Debugging Scenarios

### Compilation Errors

#### Lexer Errors
```
Error at line 5: Unexpected character '&'
Token: UNKNOWN Text: &
Error at line 5: Failed to parse module
```
**Solution**: Check for invalid characters in source code

#### Parser Errors
```
Error at line 10: Expected ':=' in assignment
Token: LPAREN Text: (
Error at line 10: Failed to parse module
```
**Solution**: Check assignment syntax, ensure `:=` is used instead of `=`

#### Type Errors
```
Error at line 15: Type mismatch
Expected: integer
Found: string
```
**Solution**: Check variable types and assignments

### VM Execution Errors

#### Invalid Address
```
Program execution failed: Invalid address
```
**Solution**: Check bytecode generation, verify instruction operands

#### Call Stack Underflow
```
Program execution failed: Call stack underflow
```
**Solution**: Check method call bytecode, verify stack operations

#### Memory Access Violation
```
Program execution failed: Memory access violation
```
**Solution**: Check array bounds, verify memory allocation

#### Infinite Loop Detection
```
VM: PC stuck at 18 for 100 steps (infinite loop detected)
VM: Execution stopped after 5000 steps (infinite loop protection)
```
**Solution**: Check label resolution, verify jump instruction targets, ensure proper loop termination conditions

### ARX Module Errors

#### Module Validation Failed
```
ARX module validation failed
Magic: ARXMOD
Version: 1
```
**Solution**: Check .arxmod file format, verify file integrity

#### Section Loading Failed
```
Failed to load code section
```
**Solution**: Check section offsets and sizes in TOC

## Debugging Techniques

### Step-by-Step Debugging

#### 1. Compiler Debugging
```bash
# Start with basic compilation
./arx -debug simple_program.arx

# Check if lexer works
# Look for token recognition errors

# Check if parser works
# Look for syntax parsing errors

# Check if code generation works
# Look for bytecode generation errors
```

#### 2. VM Debugging
```bash
# Start with basic execution
./arxvm -debug simple_program.arxmod

# Check module loading
# Look for module validation errors

# Check instruction execution
# Look for instruction execution errors

# Check runtime state
# Look for stack or memory errors
```

#### 3. ARX Module Debugging
```bash
# Inspect module format
./arxmod_info -info program.arxmod

# Check sections
./arxmod_info -sections program.arxmod

# Check bytecode
./arxmod_info -hex program.arxmod
```

### Memory Debugging

#### Valgrind
```bash
# Check for memory leaks
valgrind --leak-check=full ./arx program.arx

# Check for memory errors
valgrind --tool=memcheck ./arx program.arx
```

#### Address Sanitizer
```bash
# Compile with address sanitizer
clang -fsanitize=address -g -o arx_debug arx.c

# Run with address sanitizer
./arx_debug program.arx
```

### Performance Debugging

#### Profiling
```bash
# Profile compilation
perf record ./arx large_program.arx
perf report

# Profile execution
perf record ./arxvm program.arxmod
perf report
```

#### Timing
```bash
# Time compilation
time ./arx program.arx

# Time execution
time ./arxvm program.arxmod
```

## Debugging Tools Integration

### IDE Integration

#### VS Code
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug ARX Compiler",
            "type": "lldb",
            "request": "launch",
            "program": "${workspaceFolder}/build/arx",
            "args": ["-debug", "${file}"],
            "cwd": "${workspaceFolder}",
            "console": "integratedTerminal"
        },
        {
            "name": "Debug ARX VM",
            "type": "lldb",
            "request": "launch",
            "program": "${workspaceFolder}/vm/arxvm",
            "args": ["-debug", "${fileBasenameNoExtension}.arxmod"],
            "cwd": "${workspaceFolder}",
            "console": "integratedTerminal"
        }
    ]
}
```

#### GDB
```bash
# Debug compiler
gdb ./arx
(gdb) set args -debug program.arx
(gdb) run

# Debug VM
gdb ./arxvm
(gdb) set args -debug program.arxmod
(gdb) run
```

### Logging

#### Compiler Logging
```c
// Enable debug mode
bool debug_mode = true;

// Debug output
if (debug_mode) {
    printf("Parsing statement - token: %s\n", token_to_string(token));
}
```

#### VM Logging
```c
// Enable debug mode
bool debug_mode = true;

// Debug output
if (debug_mode) {
    printf("PC=%d: opcode=%d, level=%d, operand=%llu\n", 
           pc, opcode, level, operand);
}
```

## Best Practices

### Debugging Workflow
1. **Reproduce the Issue**: Create a minimal test case
2. **Enable Debug Output**: Use appropriate debug flags
3. **Check Compilation**: Verify source code compiles correctly
4. **Check Bytecode**: Verify generated bytecode is correct
5. **Check Execution**: Verify VM execution works correctly
6. **Isolate the Problem**: Narrow down to specific component
7. **Fix and Test**: Implement fix and verify it works

### Error Reporting
1. **Clear Error Messages**: Provide specific error information
2. **Source Location**: Include line numbers and file names
3. **Context Information**: Provide surrounding code context
4. **Expected vs Actual**: Show what was expected vs what happened
5. **Reproduction Steps**: Provide steps to reproduce the issue

### Debugging Tips
1. **Use Debug Flags**: Always enable debug output when debugging
2. **Check Bytecode**: Verify generated bytecode matches expectations
3. **Inspect Symbol Table**: Check symbol table contents
4. **Trace Execution**: Use VM debug mode to trace execution
5. **Validate Modules**: Check ARX module format and contents
6. **Test Incrementally**: Test small changes incrementally
7. **Document Issues**: Keep track of known issues and solutions

## Troubleshooting Guide

### Common Issues

#### Compilation Issues
- **Syntax Errors**: Check Pascal-style syntax
- **Type Errors**: Verify type declarations and assignments
- **Scope Errors**: Check variable and method scoping
- **Inheritance Errors**: Verify class inheritance syntax

#### VM Issues
- **Module Loading**: Check .arxmod file format
- **Instruction Execution**: Verify bytecode instructions
- **Memory Management**: Check stack and heap operations
- **Object Operations**: Verify OO operation implementation

#### Performance Issues
- **Compilation Speed**: Profile lexer, parser, and codegen
- **Execution Speed**: Profile VM instruction execution
- **Memory Usage**: Check for memory leaks and excessive allocation
- **Bytecode Size**: Optimize bytecode generation

### Getting Help
1. **Check Documentation**: Review relevant documentation
2. **Enable Debug Output**: Use debug flags to get more information
3. **Create Test Case**: Create minimal reproduction case
4. **Check Issues**: Look for similar issues in project history
5. **Ask for Help**: Provide clear description and debug output
