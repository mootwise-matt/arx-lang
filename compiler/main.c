/*
 * ARX Compiler - Main Entry Point
 * Fresh implementation starting from scratch
 * 
 * Compiles ARX source code to .arxmod bytecode files
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Compiler modules
#include "lexer/lexer.h"
#include "parser/parser.h"
#include "codegen/codegen.h"
#include "arxmod/arxmod.h"
#include "common/opcodes.h"

// Global flags
bool debug_mode = false;
bool show_bytecode = false;
bool show_symbols = false;

// Function prototypes
void print_usage(const char* program_name);
bool compile_file(const char* input_file, const char* output_file);
void print_compiler_info(void);
void display_bytecode(instruction_t *instructions, size_t instruction_count);

int main(int argc, char *argv[])
{
    // Print compiler info
    print_compiler_info();
    
    // Check command line arguments
    if (argc < 2) {
        print_usage(argv[0]);
        return 1;
    }
    
    // Parse command line arguments
    char *input_file = NULL;
    char *output_file = NULL;
    bool show_help = false;
    
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-debug") == 0) {
            debug_mode = true;
            if (debug_mode) {
                printf("Debug mode enabled\n");
            }
        }
        else if (strcmp(argv[i], "-show-bytecode") == 0 || strcmp(argv[i], "-dump") == 0) {
            show_bytecode = true;
            if (debug_mode) {
                printf("Bytecode display enabled\n");
            }
        }
        else if (strcmp(argv[i], "-show-symbols") == 0) {
            show_symbols = true;
            if (debug_mode) {
                printf("Symbol table display enabled\n");
            }
        }
        else if (strcmp(argv[i], "-o") == 0) {
            if (i + 1 < argc) {
                output_file = argv[++i];
            } else {
                printf("Error: -o requires an output filename\n");
                return 1;
            }
        }
        else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            show_help = true;
        }
        else if (argv[i][0] != '-') {
            input_file = argv[i];
        }
        else {
            printf("Error: Unknown option '%s'\n", argv[i]);
            print_usage(argv[0]);
            return 1;
        }
    }
    
    if (show_help) {
        print_usage(argv[0]);
        return 0;
    }
    
    if (input_file == NULL) {
        printf("Error: No input file specified\n");
        print_usage(argv[0]);
        return 1;
    }
    
    // Generate output filename if not provided
    if (output_file == NULL) {
        // Replace .arx extension with .arxmod
        size_t len = strlen(input_file);
        output_file = malloc(len + 10); // Extra space for .arxmod
        strcpy(output_file, input_file);
        
        // Find last dot
        char *last_dot = strrchr(output_file, '.');
        if (last_dot && strcmp(last_dot, ".arx") == 0) {
            strcpy(last_dot, ".arxmod");
        } else {
            strcat(output_file, ".arxmod");
        }
    }
    
    if (debug_mode) {
        printf("Input file: %s\n", input_file);
        printf("Output file: %s\n", output_file);
    }
    
    // Compile the file
    bool success = compile_file(input_file, output_file);
    
    if (success) {
        if (debug_mode) {
            printf("Compilation successful\n");
        }
        return 0;
    } else {
        printf("Compilation failed\n");
        return 1;
    }
}

void print_usage(const char* program_name)
{
    printf("ARX Compiler v1.0\n");
    printf("Usage: %s [options] <input_file>\n", program_name);
    printf("\n");
    printf("Options:\n");
    printf("  -debug          Enable debug output\n");
    printf("  -show-bytecode  Display generated bytecode\n");
    printf("  -show-symbols   Display symbol table\n");
    printf("  -dump           Alias for -show-bytecode\n");
    printf("  -o <file>       Specify output file (default: input.arxmod)\n");
    printf("  -h, --help      Show this help message\n");
    printf("\n");
    printf("Examples:\n");
    printf("  %s program.arx\n", program_name);
    printf("  %s -debug -o output.arxmod program.arx\n", program_name);
    printf("  %s -show-bytecode program.arx\n", program_name);
    printf("  %s -show-symbols program.arx\n", program_name);
    printf("  %s -debug -dump program.arx\n", program_name);
    printf("\n");
}

void print_compiler_info(void)
{
    if (debug_mode) {
        printf("ARX Compiler v1.0\n");
        printf("Compiled on %s %s\n", __DATE__, __TIME__);
        printf("Target: Cross-platform bytecode (.arxmod)\n");
        printf("License: Apache 2.0\n");
        printf("\n");
    }
}

void display_bytecode(instruction_t *instructions, size_t instruction_count)
{
    if (instructions == NULL || instruction_count == 0) {
        printf("No bytecode to display\n");
        return;
    }
    
    printf("\n=== Generated Bytecode ===\n");
    printf("Total instructions: %zu\n", instruction_count);
    printf("\n");
    
    for (size_t i = 0; i < instruction_count; i++) {
        instruction_t *instr = &instructions[i];
        uint8_t opcode = instr->opcode & 0xF;
        uint8_t level = (instr->opcode >> 4) & 0xF;
        uint64_t operand = instr->opt64;
        
        printf("%4zu: ", i);
        
        // Display opcode name
        switch (opcode) {
            case VM_LIT:    printf("LIT    "); break;
            case VM_OPR:    printf("OPR    "); break;
            case VM_LOD:    printf("LOD    "); break;
            case VM_STO:    printf("STO    "); break;
            case VM_CAL:    printf("CAL    "); break;
            case VM_INT:    printf("INT    "); break;
            case VM_JMP:    printf("JMP    "); break;
            case VM_JPC:    printf("JPC    "); break;
            case VM_LODX:   printf("LODX   "); break;
            case VM_STOX:   printf("STOX   "); break;
            case VM_HALT:   printf("HALT   "); break;
            default:        printf("UNK(%d) ", opcode); break;
        }
        
        // Display level and operand
        if (level > 0) {
            printf("L%d, %llu", level, (unsigned long long)operand);
        } else {
            printf("%llu", (unsigned long long)operand);
        }
        
        // For OPR instructions, show the operation
        if (opcode == VM_OPR) {
            printf(" (");
            switch (operand) {
                case OPR_RET:     printf("RET"); break;
                case OPR_NEG:     printf("NEG"); break;
                case OPR_ADD:     printf("ADD"); break;
                case OPR_SUB:     printf("SUB"); break;
                case OPR_MUL:     printf("MUL"); break;
                case OPR_DIV:     printf("DIV"); break;
                case OPR_POW:     printf("POW"); break;
                case OPR_MOD:     printf("MOD"); break;
                case OPR_ODD:     printf("ODD"); break;
                case OPR_EQ:      printf("EQ"); break;
                case OPR_NEQ:     printf("NEQ"); break;
                case OPR_LESS:    printf("LESS"); break;
                case OPR_LEQ:     printf("LEQ"); break;
                case OPR_GREATER: printf("GREATER"); break;
                case OPR_GEQ:     printf("GEQ"); break;
                // OPR_WRITELN removed - writeln is now accessed via system.writeln()
                case OPR_OBJ_NEW: printf("OBJ_NEW"); break;
                case OPR_OBJ_CALL_METHOD: printf("OBJ_CALL_METHOD"); break;
                // Field opcodes removed - fields are accessed directly by name within class methods
                default:          printf("OPR_%llu", (unsigned long long)operand); break;
            }
            printf(")");
        }
        
        printf("\n");
    }
    
    printf("\n=== End Bytecode ===\n");
}

bool compile_file(const char* input_file, const char* output_file)
{
    // Open input file
    FILE *fin = fopen(input_file, "r");
    if (fin == NULL) {
        printf("Error: Could not open input file '%s'\n", input_file);
        return false;
    }
    
    // Get file size
    fseek(fin, 0, SEEK_END);
    size_t file_size = ftell(fin);
    rewind(fin);
    
    if (debug_mode) {
        printf("Reading %zu bytes from '%s'\n", file_size, input_file);
    }
    
    // Read source code
    char *source = malloc(file_size + 1);
    if (fread(source, 1, file_size, fin) != file_size) {
        printf("Error: Could not read input file\n");
        fclose(fin);
        free(source);
        return false;
    }
    source[file_size] = '\0'; // Null terminate
    fclose(fin);
    
    if (debug_mode) {
        printf("Source code loaded successfully\n");
        printf("Starting compilation...\n");
    }
    
    // Initialize compiler components
    lexer_context_t lexer;
    parser_context_t parser;
    codegen_context_t codegen;
    
    // Initialize lexer
    if (!lexer_init(&lexer, source, file_size)) {
        printf("Error: Failed to initialize lexer\n");
        free(source);
        return false;
    }
    
    // Initialize parser
    if (!parser_init(&parser, &lexer)) {
        printf("Error: Failed to initialize parser\n");
        free(source);
        return false;
    }
    
    if (debug_mode) {
        printf("Parser initialized successfully\n");
    }
    
    // Initialize code generator
    if (!codegen_init(&codegen, &parser)) {
        printf("Error: Failed to initialize code generator\n");
        free(source);
        return false;
    }
    
    // Parse the source code
    ast_node_t *ast = parser_parse(&parser);
    if (ast == NULL || parser.error_count > 0) {
        if (parser.error_count > 0) {
            printf("Error: Parsing failed with %d errors\n", parser.error_count);
        } else {
            printf("Error: Parsing failed\n");
        }
        free(source);
        return false;
    }
    
    if (debug_mode) {
        printf("Parsing completed successfully\n");
    }
    
    // Display symbol table if requested
    if (show_symbols) {
        symbol_table_dump(&parser.symbol_table);
    }
    
    // Generate bytecode
    instruction_t *instructions = NULL;
    size_t instruction_count = 0;
    
    if (!codegen_generate(&codegen, ast, &instructions, &instruction_count)) {
        printf("Error: Code generation failed\n");
        free(source);
        return false;
    }
    
    if (debug_mode) {
        printf("Generated %zu instructions\n", instruction_count);
    }
    
    // Display bytecode if requested
    if (show_bytecode) {
        display_bytecode(instructions, instruction_count);
    }
    
    // Write output file
    if (!codegen_write_arxmod(&codegen, output_file, instructions, instruction_count)) {
        printf("Error: Failed to write output file '%s'\n", output_file);
        free(source);
        return false;
    }
    
    if (debug_mode) {
        printf("Output written to '%s'\n", output_file);
    }
    
    // Cleanup
    free(source);
    free(instructions);
    
    return true;
}
